- 本质：数学优化问题
- 要素
  - 状态转移方程（找到这个东西是最难的）
    - base case
    - state transition

![](https://imgur.com/5G70jv8.jpg)
  - 最优子结构：是否能通过子问题的最值得到原问题的最值，子问题之间必须是互相独立的
  - DP table：优化穷举中的重叠子问题

# 零钱兑换(322)：

给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 

- 这个问题是动态规划问题，因为它具有「**最优子结构**
  - 这个地方有点TRICKY它的子结构不是硬币的数量，而是总金额amount
  - 寻找全局**amount** **最少**需要的硬币: 可以分解成子问题：
    - min: amount-1**最少**需要的硬币 (+a个硬币得到amount)
    - min: amount-2**最少**需要的硬币 (+b个硬币得到amount)
    - min: amount-3**最少**需要的硬币 (+c个硬币得到amount)
  - 因为**每种硬币的数量无限**, 每个子问题之间不存在相互制约（互相独立的）

## so

- base case: amount 为 0 时算法返回 0
- 状态： f(amount): return **最少**需要的硬币
- 变量：[x1, x2, ... xk] 每种硬币的数量
- 最优状态转移：
  - f(amount) = 
    - min: for every coin:
       - f(amount-coin) + 1 
 